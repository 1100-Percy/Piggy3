{% extends 'base.html' %}

{% block content %}
<div class="d-flex flex-column h-100 min-vh-100">
    <!-- Graph Section (60%) -->
    <div id="graph-container" class="flex-grow-1 position-relative" style="height: 60vh; overflow: hidden;">
        <div id="mynetwork" class="w-100 h-100"></div>
        <!-- Piggy Hint -->
        <div class="position-absolute top-0 start-0 m-3 p-2 bg-white rounded shadow text-small" style="max-width: 200px;">
            <span class="fs-4">üê∑</span> Click nodes to explore!
        </div>
    </div>

    <!-- Tasks Section (40%) -->
    <div class="bg-white p-4 rounded-top-4 shadow-lg position-relative" style="height: 40vh; margin-top: -20px; z-index: 10;">
        <h4 class="fw-bold mb-3" style="color: #5D4037;">Today's Menu</h4>
        <div id="task-list" class="overflow-auto" style="height: calc(100% - 50px);">
            <!-- Tasks injected here -->
            <div class="text-center mt-5 text-muted">
                <div class="spinner-border text-warning" role="status"></div>
                <p>Loading Ingredients...</p>
            </div>
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', async () => {
        // Fetch Data
        try {
            const res = await fetch('/api/get_dashboard_data/');
            const data = await res.json();
            
            if (data.status === 'success') {
                // Apply background based on thinking type
                const graphContainer = document.getElementById('graph-container');
                graphContainer.classList.remove('bg-soup-clear', 'bg-soup-red');
                
                if (data.thinking_type === 'convergent') {
                    graphContainer.classList.add('bg-soup-red');
                } else {
                    graphContainer.classList.add('bg-soup-clear');
                }

                renderGraph(data.graph, data.thinking_type);
                renderTasks(data.tasks);
            } else {
                alert("Failed to load data: " + data.message);
                window.location.href = '/login/';
            }
        } catch (err) {
            console.error(err);
            // Offline Fallback logic would go here
        }
    });

    function renderGraph(graphData, thinkingType) {
        const container = document.getElementById('mynetwork');
        
        // Safety check for hierarchical layout: ensure all nodes have a level
        if (thinkingType === 'convergent') {
            graphData.nodes.forEach(node => {
                if (node.level === undefined) {
                    node.level = 1; // Default level if missing
                }
            });
        }
        
        const nodes = new vis.DataSet(graphData.nodes);
        const edges = new vis.DataSet(graphData.edges);
        
        const data = { nodes, edges };
        const options = {
            nodes: {
                shape: 'box',
                margin: 10,
                widthConstraint: { maximum: 200 },
                font: { size: 18, face: 'arial', multi: true },
                color: {
                    background: '#FFD54F',
                    border: '#FFA000',
                    highlight: { background: '#FFE082', border: '#FF6F00' }
                },
                shadow: true
            },
            edges: {
                color: '#8D6E63',
                width: 2,
                smooth: {
                    type: thinkingType === 'convergent' ? 'cubicBezier' : 'continuous',
                    forceDirection: thinkingType === 'convergent' ? 'vertical' : 'none',
                    roundness: 0.4
                }
            },
            layout: {
                hierarchical: {
                    enabled: thinkingType === 'convergent',
                    direction: 'UD',
                    sortMethod: 'directed',
                    nodeSpacing: 250,
                    levelSeparation: 150
                }
            },
            physics: {
                enabled: thinkingType === 'divergent', // Enable physics for network graph
                barnesHut: {
                    gravitationalConstant: -2000,
                    centralGravity: 0.3,
                    springLength: 150
                }
            },
            interaction: {
                dragNodes: true,
                dragView: true,
                zoomView: true
            }
        };
        
        const network = new vis.Network(container, data, options);
        
        // --- Folding/Unfolding Logic ---
        network.on("selectNode", function (params) {
            // Using 'selectNode' event is safer than 'click' for interaction handling
            if (params.nodes.length > 0) {
                const nodeId = params.nodes[0];
                
                // Get connected nodes (children)
                const connectedNodes = network.getConnectedNodes(nodeId, 'to'); 
                
                if (connectedNodes.length > 0) {
                    // Check if children are currently visible
                    const firstChild = connectedNodes[0];
                    const isVisible = !nodes.get(firstChild).hidden;
                    
                    // Toggle visibility
                    toggleChildren(nodeId, !isVisible);
                } else {
                    // Leaf node clicked: just zoom to it
                    network.focus(nodeId, {
                        animation: { duration: 500, easingFunction: 'easeInOutQuad' },
                        scale: 1.2
                    });
                }
            }
        });
        // -------------------------------

        function toggleChildren(parentId, show, visited = new Set()) {
            // Prevent infinite loops in mesh networks
            if (visited.has(parentId)) return;
            visited.add(parentId);

            const children = network.getConnectedNodes(parentId, 'to');
            
            children.forEach(childId => {
                // Update node visibility
                nodes.update({id: childId, hidden: !show});
                
                // If hiding, recursively hide grandchildren
                // If showing, we stay at direct children for a "step-by-step" expand feel
                if (!show) {
                    toggleChildren(childId, false, visited);
                }
            });
            
            // Adjust layout after visibility change
            // network.fit({ animation: { duration: 500, easingFunction: 'easeInOutQuad' } });
        }
        // -------------------------------
    }

    function renderTasks(tasks) {
        const list = document.getElementById('task-list');
        list.innerHTML = '';
        
        if (tasks.length === 0) {
            list.innerHTML = '<p class="text-center text-muted">All dishes cooked! Good job!</p>';
            return;
        }

        tasks.forEach(task => {
            const isDone = task.is_completed;
            const card = document.createElement('div');
            card.className = `card mb-3 border-0 shadow-sm ${isDone ? 'bg-light text-muted' : 'bg-white'}`;
            card.innerHTML = `
                <div class="card-body d-flex justify-content-between align-items-center p-3" onclick="${!isDone ? `location.href='/task_detail/?id=${task.id}'` : ''}" style="cursor: pointer;">
                    <div class="d-flex align-items-center">
                        <span class="fs-4 me-3">${isDone ? '‚úÖ' : 'üî™'}</span>
                        <h6 class="mb-0 ${isDone ? 'text-decoration-line-through' : 'fw-bold'}">${task.content}</h6>
                    </div>
                    ${!isDone ? '<span class="text-primary">></span>' : ''}
                </div>
            `;
            list.appendChild(card);
        });
    }
</script>
{% endblock %}
