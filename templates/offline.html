{% extends 'base.html' %}

{% block content %}
<div class="d-flex flex-column align-items-center justify-content-center min-vh-100 kitchen-bg text-center">
    <div class="piggy-face bg-white rounded-circle shadow mb-4 d-flex align-items-center justify-content-center border border-3 border-secondary" style="width: 150px; height: 150px; font-size: 80px;">
        üê∑üò∑
    </div>
    
    <h2 class="fw-bold mb-3" style="color: #5D4037;">No Internet? No Problem!</h2>
    <p class="lead mb-5" style="color: #795548;">The kitchen is always open for practice.</p>

    <button id="offline-start-btn" class="btn btn-secondary btn-lg px-5 py-3 shadow-lg">
        Start Offline Demo
    </button>
</div>

<script>
    document.getElementById('offline-start-btn').addEventListener('click', () => {
        // Load offline data from localStorage
        const offlineData = localStorage.getItem('offline_samples');
        if (offlineData) {
            alert("Loading Offline Pantry...");
            // In a real app, we'd load this data into the State Management (Vue/React Store)
            // For this Django Template app, we might redirect to a specific 'offline_mode' page 
            // or just let the Service Worker handle the 'fetch' requests by returning cached API responses.
            // Since we don't have a sophisticated SW API mocking strategy here, 
            // we will redirect to 'select' and assume the user knows it's a demo.
            window.location.href = '/select/';
        } else {
            alert("No offline ingredients found. Please connect once to download them.");
        }
    });
</script>
{% endblock %}
